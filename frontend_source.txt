=======
src/reportWebVitals.js
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

src/App.css
@import './styles/components.css';

:root {
  --primary-color: #1976d2;
  --secondary-color: #dc004e;
  --background-color: #ffffff;
  --surface-color: #f5f5f5;
  --text-color: #000000;
  --text-secondary-color: #666666;
  --border-color: #e0e0e0;
  --font-primary: 'Roboto', sans-serif;
  --font-secondary: 'Roboto', sans-serif;
  --border-radius: 4px;
}

.App {
  font-family: var(--font-primary);
  padding: 20px;
  max-width: 1200px;
  margin: 0 auto;
  background-color: var(--background-color);
  color: var(--text-color);
}

nav {
  background-color: var(--surface-color);
  border-radius: var(--border-radius);
  padding: 10px;
  margin-bottom: 20px;
}

nav ul {
  list-style: none;
  padding: 0;
  display: flex;
  gap: 20px;
  margin-bottom: 30px;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 15px;
}

nav a {
  text-decoration: none;
  color: var(--text-color);
  padding: 8px 12px;
  border-radius: var(--border-radius);
  background-color: var(--surface-color);
  transition: all 0.2s ease;
  font-family: var(--font-secondary);
}

nav a:hover {
  background-color: var(--primary-color);
  color: white;
}

nav button {
  padding: 8px 12px;
  border: none;
  border-radius: var(--border-radius);
  background-color: var(--secondary-color);
  color: white;
  cursor: pointer;
  transition: all 0.2s ease;
  font-family: var(--font-secondary);
}

nav button:hover {
  filter: brightness(90%);
}

.content {
  margin-top: 20px;
  background-color: var(--surface-color);
  padding: 20px;
  border-radius: var(--border-radius);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Form Styles */
form {
  max-width: 400px;
  margin: 0 auto;
  padding: 20px;
  background-color: var(--surface-color);
  border-radius: var(--border-radius);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

input, textarea {
  width: 100%;
  padding: 8px;
  margin-bottom: 10px;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  font-size: 14px;
  font-family: var(--font-primary);
  background-color: var(--background-color);
  color: var(--text-color);
}

input:focus, textarea:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
}

button {
  padding: 8px 16px;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--border-radius);
  cursor: pointer;
  margin-right: 10px;
  font-family: var(--font-secondary);
  transition: all 0.2s ease;
}

button:hover {
  filter: brightness(90%);
}

button:disabled {
  background-color: var(--border-color);
  cursor: not-allowed;
}

/* Headings */
h1, h2, h3 {
  color: var(--text-color);
  margin-bottom: 20px;
  font-family: var(--font-secondary);
}

h1 {
  font-size: 2em;
  color: var(--primary-color);
}

h2 {
  font-size: 1.5em;
}

h3 {
  font-size: 1.2em;
  color: var(--text-secondary-color);
}

/* Theme-specific styles */
.wood-theme {
  background-attachment: fixed;
  background-position: center;
}

.metallic-theme {
  background-attachment: fixed;
}

/* Dark mode adjustments */
@media (prefers-color-scheme: dark) {
  :root {
    --background-color: #121212;
    --surface-color: #1e1e1e;
    --text-color: #ffffff;
    --text-secondary-color: #aaaaaa;
    --border-color: #333333;
  }
}

src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

src/index.css
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

src/config.js
export const config = {
  DEBUG: process.env.REACT_APP_DEBUG,
  NETLIFY_FUNC_URL: process.env.REACT_APP_NETLIFY_FUNC_URL
};

src/styles/fonts.css
/* Roboto for MUI theme */
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

/* Merriweather and Lora for Wood theme */
@import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Lora:wght@400;500;600&display=swap');

/* Rajdhani and Orbitron for Metallic theme */
@import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600&family=Orbitron:wght@400;500;600&display=swap');

src/styles/components.css
/* Project View Styles */
.project-workflow {
  margin: 30px 0;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
}

.workflow-steps {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.workflow-step {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.workflow-step h4 {
  color: #007bff;
  margin-bottom: 10px;
}

.workflow-step p {
  color: #6c757d;
  margin-bottom: 15px;
  font-size: 0.9em;
}

.workflow-step .button {
  width: 100%;
  text-align: center;
}

.workflow-step .button:disabled {
  background-color: #e9ecef;
  color: #6c757d;
  cursor: not-allowed;
}

.project-sections {
  display: grid;
  grid-template-columns: 1fr;
  gap: 20px;
  margin-top: 20px;
}

.project-sections section {
  background: #f5f5f5;
  padding: 20px;
  border-radius: 8px;
}

.project-sections ul {
  list-style: none;
  padding: 0;
}

.project-sections li {
  margin-bottom: 15px;
  padding: 10px;
  background: white;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

/* Criteria Definition Styles */
.criteria-form {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

.criteria-section {
  margin-bottom: 30px;
  padding: 20px;
  background: #f5f5f5;
  border-radius: 8px;
}

.criteria-item {
  display: grid;
  grid-template-columns: 2fr 3fr 1fr auto;
  gap: 10px;
  margin-bottom: 15px;
  padding: 10px;
  background: white;
  border-radius: 4px;
  align-items: center;
}

.criteria-item input[type="text"] {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

.criteria-item input[type="number"] {
  width: 60px;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

/* Button Styles */
.button {
  display: inline-block;
  padding: 8px 16px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  text-decoration: none;
  font-size: 14px;
}

.button:hover {
  background-color: #0056b3;
}

.button:disabled,
.button.disabled {
  background-color: #ccc !important;
  cursor: not-allowed;
  opacity: 0.7;
  pointer-events: none;
}

.button-secondary {
  background-color: #6c757d;
}

.button-secondary:hover {
  background-color: #545b62;
}

.button-danger {
  background-color: #dc3545;
}

.button-danger:hover {
  background-color: #c82333;
}

/* Error Message Styles */
.error {
  color: #dc3545;
  padding: 10px;
  margin: 10px 0;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 4px;
}

/* Loading State Styles */
.loading {
  opacity: 0.7;
  pointer-events: none;
}

/* Form Builder Styles */
.form-builder {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

.fields-container {
  display: flex;
  flex-direction: column;
  gap: 20px;
  margin-bottom: 20px;
}

.field-item {
  background: #f5f5f5;
  padding: 20px;
  border-radius: 8px;
}

.field-header {
  display: grid;
  grid-template-columns: 2fr 1fr auto auto;
  gap: 10px;
  align-items: center;
  margin-bottom: 10px;
}

.field-header label {
  display: flex;
  align-items: center;
  gap: 5px;
}

.field-header input[type="checkbox"] {
  width: auto;
  margin: 0;
}

.options-container {
  margin-top: 15px;
  padding: 15px;
  background: white;
  border-radius: 4px;
}

.option-item {
  display: grid;
  grid-template-columns: 1fr 1fr auto;
  gap: 10px;
  margin-bottom: 10px;
  align-items: center;
}

/* Alternative Evaluation Styles */
.alternative-evaluation {
  max-width: 1000px;
  margin: 0 auto;
  padding: 20px;
}

.evaluation-sections {
  display: grid;
  grid-template-columns: 1fr;
  gap: 30px;
  margin-top: 20px;
}

.new-alternative {
  background: #f8f9fa;
  padding: 20px;
  border-radius: 8px;
}

.form-field {
  margin-bottom: 15px;
}

.form-field label {
  display: block;
  margin-bottom: 5px;
  font-weight: 500;
}

.form-field input,
.form-field select {
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

.alternatives-list {
  background: #f8f9fa;
  padding: 20px;
  border-radius: 8px;
}

.alternatives-list table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 15px;
  background: white;
  border-radius: 4px;
  overflow: hidden;
}

.alternatives-list th,
.alternatives-list td {
  padding: 12px;
  text-align: left;
  border-bottom: 1px solid #ddd;
}

.alternatives-list th {
  background: #f1f3f5;
  font-weight: 600;
}

.alternatives-list tr.disqualified {
  background: #fff5f5;
}

.alternatives-list tr.disqualified td {
  color: #dc3545;
}

/* AI Assistance Styles */
.ai-assistance {
  background: #e3f2fd;
  padding: 20px;
  border-radius: 8px;
  margin-bottom: 20px;
  border-left: 4px solid #1976d2;
}

.ai-assistance p {
  color: #1976d2;
  margin: 0 0 15px 0;
  font-weight: 500;
}

.criteria-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.criteria-header h2 {
  margin: 0;
}

/* Loading States */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* AI Evaluation Status */
.ai-status {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  background: #e3f2fd;
  border-radius: 4px;
  font-size: 0.9em;
  color: #1976d2;
}

.ai-status.evaluating {
  background: #fff3e0;
  color: #f57c00;
}

.ai-status.complete {
  background: #e8f5e9;
  color: #43a047;
}

/* Theme Selector Styles */
.theme-selector {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: var(--surface-color, #f5f5f5);
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  z-index: 1000;
}

.theme-buttons {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
}

.theme-button {
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 14px;
}

.theme-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.theme-button.active {
  transform: translateY(1px);
  box-shadow: none;
}

.dark-mode-toggle {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 10px;
}

.dark-mode-toggle label {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  color: var(--text-color, #000);
}

.dark-mode-toggle input[type="checkbox"] {
  width: 40px;
  height: 20px;
  position: relative;
  appearance: none;
  background: #ddd;
  border-radius: 10px;
  cursor: pointer;
  transition: background 0.3s;
}

.dark-mode-toggle input[type="checkbox"]::before {
  content: '';
  position: absolute;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  top: 1px;
  left: 1px;
  background: white;
  transition: transform 0.3s;
}

.dark-mode-toggle input[type="checkbox"]:checked {
  background: #007bff;
}

.dark-mode-toggle input[type="checkbox"]:checked::before {
  transform: translateX(20px);
}

/* New Project Form Styles */
.new-project-form {
  max-width: 800px;
  margin: 20px auto;
  padding: 20px;
  background: var(--surface-color);
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.form-section {
  margin-bottom: 20px;
}

.form-section input,
.form-section textarea {
  width: 100%;
  margin-bottom: 15px;
}

.warning-banner {
  background: #fff3cd;
  color: #856404;
  padding: 12px;
  margin: 15px 0;
  border-radius: 4px;
  border-left: 4px solid #ffc107;
  font-weight: 500;
  text-align: center;
}

.ai-suggestions {
  margin-top: 20px;
  padding: 20px;
  background: #fff5f5;
  border-radius: 8px;
}

.bulk-actions {
  display: flex;
  gap: 10px;
  margin: 15px 0;
  justify-content: center;
}

.criteria-sections {
  display: grid;
  gap: 20px;
  margin: 20px 0;
}

.criteria-item {
  background: white;
  padding: 15px;
  border-radius: 4px;
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
}

.criteria-item.pending {
  background: #fff5f5;
  border-left: 4px solid #dc3545;
}

.criteria-content {
  flex: 1;
}

.criteria-content strong {
  display: block;
  margin-bottom: 5px;
  color: var(--text-color);
}

.criteria-content p {
  color: var(--text-secondary-color);
  margin: 5px 0;
  font-size: 0.9em;
}

.criteria-content .weight {
  display: inline-block;
  background: #e9ecef;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  color: #495057;
}

.criteria-actions {
  margin-left: 15px;
}

.projects-list {
  list-style: none;
  padding: 0;
  margin-top: 20px;
}

.projects-list li {
  background: var(--surface-color);
  margin-bottom: 15px;
  border-radius: 8px;
  overflow: hidden;
  transition: transform 0.2s;
}

.projects-list li:hover {
  transform: translateY(-2px);
}

.projects-list a {
  display: block;
  padding: 20px;
  text-decoration: none;
  color: var(--text-color);
}

.projects-list h3 {
  margin: 0 0 10px 0;
  color: var(--primary-color);
}

.projects-list p {
  margin: 0;
  color: var(--text-secondary-color);
}

.project-status {
  display: flex;
  gap: 10px;
  margin-top: 10px;
}

.status-badge {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  background: #e9ecef;
  color: #495057;
}

.status-badge.ai-suggested {
  background: #e3f2fd;
  color: #1976d2;
  border-left: 2px solid #1976d2;
}

/* Responsive Design */
@media (min-width: 768px) {
  .project-sections {
    grid-template-columns: 1fr 1fr;
  }

  .evaluation-sections {
    grid-template-columns: 1fr 1fr;
  }

  .criteria-sections {
    grid-template-columns: 1fr 1fr;
  }
}

@media (max-width: 600px) {
  .theme-selector {
    bottom: 10px;
    right: 10px;
    left: 10px;
    padding: 10px;
  }

  .theme-buttons {
    flex-direction: column;
  }

  .criteria-item {
    flex-direction: column;
  }

  .criteria-actions {
    margin-left: 0;
    margin-top: 10px;
    width: 100%;
    display: flex;
    justify-content: flex-end;
  }

  .bulk-actions {
    flex-direction: column;
  }
}

src/components/CriteriaDefinition.js
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { authService } from '../services/auth';
import { aiService } from '../services/ai';
import { config } from '../config';

function CriteriaDefinition() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [project, setProject] = useState(null);
  const [mustHaveCriteria, setMustHaveCriteria] = useState([{ id: Date.now(), name: '', description: '' }]);
  const [wantCriteria, setWantCriteria] = useState([{ id: Date.now(), name: '', description: '', weight: 1 }]);
  const [isGenerating, setIsGenerating] = useState(false);

  const addMustHaveCriteria = () => {
    setMustHaveCriteria([...mustHaveCriteria, { id: Date.now(), name: '', description: '' }]);
  };

  const addWantCriteria = () => {
    setWantCriteria([...wantCriteria, { id: Date.now(), name: '', description: '', weight: 1 }]);
  };

  const updateMustHaveCriteria = (id, field, value) => {
    setMustHaveCriteria(mustHaveCriteria.map(criteria => 
      criteria.id === id ? { ...criteria, [field]: value } : criteria
    ));
  };

  const updateWantCriteria = (id, field, value) => {
    setWantCriteria(wantCriteria.map(criteria => 
      criteria.id === id ? { ...criteria, [field]: value } : criteria
    ));
  };

  const removeMustHaveCriteria = (id) => {
    if (mustHaveCriteria.length > 1) {
      setMustHaveCriteria(mustHaveCriteria.filter(criteria => criteria.id !== id));
    }
  };

  const removeWantCriteria = (id) => {
    setWantCriteria(wantCriteria.filter(criteria => criteria.id !== id));
  };

  useEffect(() => {
    const fetchProject = async () => {
      try {
        const { session } = await authService.getSession();
        const response = await fetch(`${config.NETLIFY_FUNC_URL}/projects/${id}`, {
          headers: {
            'Authorization': `Bearer ${session.access_token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error('Failed to fetch project');
        }

        const data = await response.json();
        setProject(data);
      } catch (error) {
        setError(error.message);
      }
    };

    fetchProject();
  }, [id]);

  const generateCriteria = async () => {
    if (!project?.name) return;
    
    setIsGenerating(true);
    try {
      const suggestions = await aiService.generateCriteria(project.name);
      
      // Convert AI suggestions to our format with IDs
      const newMustHave = suggestions.mustHave.map(criteria => ({
        id: Date.now() + Math.random(),
        ...criteria
      }));
      
      const newWant = suggestions.want.map(criteria => ({
        id: Date.now() + Math.random(),
        ...criteria
      }));

      setMustHaveCriteria(newMustHave);
      setWantCriteria(newWant);
    } catch (error) {
      setError(error.message);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    try {
      // Validate Must-Have criteria
      const validMustHave = mustHaveCriteria.filter(c => c.name.trim());
      if (validMustHave.length === 0) {
        throw new Error('At least one Must-Have criteria is required');
      }

      // Filter out empty criteria
      const validWant = wantCriteria.filter(c => c.name.trim());

      const { session } = await authService.getSession();
      const response = await fetch(`${config.NETLIFY_FUNC_URL}/projects/${id}/criteria`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          mustHave: validMustHave,
          want: validWant
        })
      });

      if (!response.ok) {
        throw new Error('Failed to save criteria');
      }

      navigate(`/projects/${id}`);
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="criteria-form">
      <div className="criteria-header">
        <h2>Define Decision Criteria</h2>
        {project && (
          <button
            type="button"
            onClick={generateCriteria}
            disabled={isGenerating || !project.name}
            className="button button-secondary"
          >
            {isGenerating ? 'Generating...' : 'Get AI Suggestions'}
          </button>
        )}
      </div>
      
      {error && <div className="error">{error}</div>}
      
      <form onSubmit={handleSubmit}>
        <section className="criteria-section">
          <h3>Must-Have Criteria</h3>
          <p>These are mandatory requirements. Alternatives that don't meet these criteria will be disqualified.</p>
          {mustHaveCriteria.map((criteria, index) => (
            <div key={criteria.id} className="criteria-item">
              <input
                type="text"
                placeholder="Criteria Name"
                value={criteria.name}
                onChange={(e) => updateMustHaveCriteria(criteria.id, 'name', e.target.value)}
                disabled={loading}
              />
              <input
                type="text"
                placeholder="Description"
                value={criteria.description}
                onChange={(e) => updateMustHaveCriteria(criteria.id, 'description', e.target.value)}
                disabled={loading}
              />
              {mustHaveCriteria.length > 1 && (
                <button
                  type="button"
                  onClick={() => removeMustHaveCriteria(criteria.id)}
                  disabled={loading}
                  className="button button-danger"
                >
                  Remove
                </button>
              )}
            </div>
          ))}
          <button 
            type="button" 
            onClick={addMustHaveCriteria} 
            disabled={loading}
            className="button button-secondary"
          >
            Add Must-Have Criteria
          </button>
        </section>

        <section className="criteria-section">
          <h3>Want Criteria</h3>
          <p>These are desired attributes. Each will be scored and weighted to calculate the final score.</p>
          {wantCriteria.map((criteria) => (
            <div key={criteria.id} className="criteria-item">
              <input
                type="text"
                placeholder="Criteria Name"
                value={criteria.name}
                onChange={(e) => updateWantCriteria(criteria.id, 'name', e.target.value)}
                disabled={loading}
              />
              <input
                type="text"
                placeholder="Description"
                value={criteria.description}
                onChange={(e) => updateWantCriteria(criteria.id, 'description', e.target.value)}
                disabled={loading}
              />
              <input
                type="number"
                min="1"
                max="10"
                value={criteria.weight}
                onChange={(e) => updateWantCriteria(criteria.id, 'weight', parseInt(e.target.value, 10))}
                disabled={loading}
              />
              <button
                type="button"
                onClick={() => removeWantCriteria(criteria.id)}
                disabled={loading}
                className="button button-danger"
              >
                Remove
              </button>
            </div>
          ))}
          <button 
            type="button" 
            onClick={addWantCriteria} 
            disabled={loading}
            className="button button-secondary"
          >
            Add Want Criteria
          </button>
        </section>

        <button 
          type="submit" 
          disabled={loading}
          className="button"
        >
          Save Criteria
        </button>
      </form>
    </div>
  );
}

export default CriteriaDefinition;

src/components/ProjectView.js
import React, { useState, useEffect } from 'react';
import { useParams, Link } from 'react-router-dom';
import { authService } from '../services/auth';

import { config } from '../config';

function ProjectView() {
  const { id } = useParams();
  const [project, setProject] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchProject = async () => {
      try {
        const { session } = await authService.getSession();
        const response = await fetch(`${config.NETLIFY_FUNC_URL}/projects/${id}`, {
          headers: {
            'Authorization': `Bearer ${session.access_token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error('Failed to fetch project');
        }

        const data = await response.json();
        setProject(data);
      } catch (error) {
        setError(error.message);
      } finally {
        setLoading(false);
      }
    };

    fetchProject();
  }, [id]);

  if (loading) {
    return <p>Loading project...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  if (!project) {
    return <p>Project not found.</p>;
  }

  return (
    <div>
      <h2>{project.name}</h2>
      <p>{project.description}</p>
      
      <div className="project-workflow">
        <h3>Project Setup Steps</h3>
        <div className="workflow-steps">
          <div className="workflow-step">
            <h4>1. Define Criteria</h4>
            <p>Set up Must-Have and Want criteria for evaluation</p>
            <Link to={`/projects/${id}/criteria`} className="button">
              {project.criteria ? 'Edit Criteria' : 'Define Criteria'}
            </Link>
          </div>

          <div className="workflow-step">
            <h4>2. Create Input Form</h4>
            <p>Design the form for collecting alternative details</p>
            <Link to={`/projects/${id}/form`} className="button">
              {project.form_schema ? 'Edit Form' : 'Create Form'}
            </Link>
          </div>

          <div className="workflow-step">
            <h4>3. Evaluate Alternatives</h4>
            <p>Add and evaluate alternatives based on criteria</p>
            <Link
              to={`/projects/${id}/evaluate`}
              className={`button ${(!project.criteria || !project.form_schema) ? 'disabled' : ''}`}
              onClick={(e) => {
                if (!project.criteria || !project.form_schema) {
                  e.preventDefault();
                }
              }}
              title={!project.criteria ? 'Define criteria first' : !project.form_schema ? 'Create input form first' : ''}
            >
              Start Evaluation
            </Link>
          </div>
        </div>
      </div>

      <div className="project-sections">
        <section>
          <h3>Must-Have Criteria</h3>
          {project.criteria?.must_have ? (
            <ul>
              {project.criteria.must_have.map((criteria, index) => (
                <li key={index}>
                  <strong>{criteria.name}</strong>
                  {criteria.description && <p>{criteria.description}</p>}
                </li>
              ))}
            </ul>
          ) : (
            <p>No must-have criteria defined yet.</p>
          )}
        </section>

        <section>
          <h3>Want Criteria</h3>
          {project.criteria?.want ? (
            <ul>
              {project.criteria.want.map((criteria, index) => (
                <li key={index}>
                  <strong>{criteria.name}</strong> (Weight: {criteria.weight})
                  {criteria.description && <p>{criteria.description}</p>}
                </li>
              ))}
            </ul>
          ) : (
            <p>No want criteria defined yet.</p>
          )}
        </section>
      </div>
    </div>
  );
}

export default ProjectView;

src/components/ThemeSelector.js
import React from 'react';
import { useTheme, themes } from '../themes/ThemeContext';

function ThemeSelector() {
  const { theme, changeTheme, isDarkMode, toggleDarkMode } = useTheme();

  return (
    <div className="theme-selector" data-testid="theme-selector">
      <div className="theme-buttons">
        <button
          className={`theme-button ${theme.name === 'mui' ? 'active' : ''}`}
          onClick={() => changeTheme('mui')}
          style={{
            backgroundColor: themes.mui.colors.primary,
            color: '#fff',
            border: `2px solid ${theme.name === 'mui' ? themes.mui.colors.secondary : 'transparent'}`
          }}
        >
          MUI Theme
        </button>
        <button
          className={`theme-button ${theme.name === 'wood' ? 'active' : ''}`}
          onClick={() => changeTheme('wood')}
          style={{
            backgroundColor: themes.wood.colors.primary,
            color: '#fff',
            border: `2px solid ${theme.name === 'wood' ? themes.wood.colors.secondary : 'transparent'}`
          }}
        >
          Wood Theme
        </button>
        <button
          className={`theme-button ${theme.name === 'metallic' ? 'active' : ''}`}
          onClick={() => changeTheme('metallic')}
          style={{
            backgroundColor: themes.metallic.colors.primary,
            color: '#fff',
            border: `2px solid ${theme.name === 'metallic' ? themes.metallic.colors.secondary : 'transparent'}`
          }}
        >
          Metallic Theme
        </button>
      </div>
      <div className="dark-mode-toggle">
        <label>
          <input
            type="checkbox"
            checked={isDarkMode}
            onChange={toggleDarkMode}
          />
          Dark Mode
        </label>
      </div>
    </div>
  );
}

export default ThemeSelector;

src/components/Auth.js
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { authService } from '../services/auth';

function Auth({ onSignIn }) {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [loading, setLoading] = useState(false);
    const navigate = useNavigate();

    const handleSignUp = async (e) => {
        e.preventDefault();
        setLoading(true);
        try {
            const { message } = await authService.signUp(email, password);
            alert(message);
            navigate('/'); // Navigate after successful sign-up
        } catch (error) {
            alert(error.message);
        } finally {
            setLoading(false);
        }
    };

    const handleLocalSignIn = async (e) => {
        e.preventDefault();
        setLoading(true);
        try {
            await authService.signIn(email, password);
            onSignIn(); // Call the onSignIn callback from props
        } catch (error) {
            alert(error.message);
        } finally {
            setLoading(false);
        }
    };

    return (
        <div>
            <h2>Sign Up / Sign In</h2>
            <form onSubmit={handleSignUp}>
                <input
                    type="email"
                    placeholder="Email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    disabled={loading}
                />
                <input
                    type="password"
                    placeholder="Password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    disabled={loading}
                />
                <button type="submit" disabled={loading}>
                    Sign Up
                </button>
                <button onClick={handleLocalSignIn} disabled={loading}>
                    Sign In
                </button>
            </form>
        </div>
    );
}

export default Auth;

src/components/FormBuilder.js
import React, { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { authService } from '../services/auth';
import { config } from '../config';

const FIELD_TYPES = [
  { value: 'text', label: 'Text' },
  { value: 'number', label: 'Number' },
  { value: 'boolean', label: 'Yes/No' },
  { value: 'select', label: 'Multiple Choice' },
  { value: 'date', label: 'Date' }
];

function FormBuilder() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [fields, setFields] = useState([
    { id: Date.now(), name: '', type: 'text', required: false, options: [] }
  ]);

  const addField = () => {
    setFields([...fields, { 
      id: Date.now(), 
      name: '', 
      type: 'text', 
      required: false,
      options: []
    }]);
  };

  const updateField = (id, updates) => {
    setFields(fields.map(field => 
      field.id === id ? { ...field, ...updates } : field
    ));
  };

  const removeField = (id) => {
    setFields(fields.filter(field => field.id !== id));
  };

  const addOption = (fieldId) => {
    setFields(fields.map(field => {
      if (field.id === fieldId) {
        return {
          ...field,
          options: [...field.options, { id: Date.now(), value: '', label: '' }]
        };
      }
      return field;
    }));
  };

  const updateOption = (fieldId, optionId, updates) => {
    setFields(fields.map(field => {
      if (field.id === fieldId) {
        return {
          ...field,
          options: field.options.map(option =>
            option.id === optionId ? { ...option, ...updates } : option
          )
        };
      }
      return field;
    }));
  };

  const removeOption = (fieldId, optionId) => {
    setFields(fields.map(field => {
      if (field.id === fieldId) {
        return {
          ...field,
          options: field.options.filter(option => option.id !== optionId)
        };
      }
      return field;
    }));
  };

  const generateSchema = () => {
    const properties = {};
    const required = [];

    fields.forEach(field => {
      if (!field.name.trim()) return;

      const propertyName = field.name.toLowerCase().replace(/\s+/g, '_');
      
      let property = {
        title: field.name,
        type: field.type === 'number' ? 'number' : 'string'
      };

      if (field.type === 'boolean') {
        property.type = 'boolean';
      } else if (field.type === 'select') {
        property.enum = field.options.map(opt => opt.value);
        property.enumNames = field.options.map(opt => opt.label);
      } else if (field.type === 'date') {
        property.format = 'date';
      }

      if (field.required) {
        required.push(propertyName);
      }

      properties[propertyName] = property;
    });

    return {
      type: 'object',
      properties,
      required
    };
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    try {
      // Validate fields
      const validFields = fields.filter(f => f.name.trim());
      if (validFields.length === 0) {
        throw new Error('At least one field is required');
      }

      // Validate select field options
      const invalidSelectField = validFields.find(
        f => f.type === 'select' && f.options.length === 0
      );
      if (invalidSelectField) {
        throw new Error(`Field "${invalidSelectField.name}" requires at least one option`);
      }

      const schema = generateSchema();
      const { session } = await authService.getSession();
      const response = await fetch(`${config.NETLIFY_FUNC_URL}/projects/${id}/form-schema`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ schema })
      });

      if (!response.ok) {
        throw new Error('Failed to save form schema');
      }

      navigate(`/projects/${id}`);
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="form-builder">
      <h2>Define Alternative Input Form</h2>
      {error && <div className="error">{error}</div>}
      
      <form onSubmit={handleSubmit}>
        <div className="fields-container">
          {fields.map((field) => (
            <div key={field.id} className="field-item">
              <div className="field-header">
                <input
                  type="text"
                  placeholder="Field Name"
                  value={field.name}
                  onChange={(e) => updateField(field.id, { name: e.target.value })}
                  disabled={loading}
                />
                <select
                  value={field.type}
                  onChange={(e) => updateField(field.id, { type: e.target.value })}
                  disabled={loading}
                >
                  {FIELD_TYPES.map(type => (
                    <option key={type.value} value={type.value}>
                      {type.label}
                    </option>
                  ))}
                </select>
                <label>
                  <input
                    type="checkbox"
                    checked={field.required}
                    onChange={(e) => updateField(field.id, { required: e.target.checked })}
                    disabled={loading}
                  />
                  Required
                </label>
                <button
                  type="button"
                  onClick={() => removeField(field.id)}
                  disabled={loading}
                  className="button button-danger"
                >
                  Remove
                </button>
              </div>

              {field.type === 'select' && (
                <div className="options-container">
                  <h4>Options</h4>
                  {field.options.map(option => (
                    <div key={option.id} className="option-item">
                      <input
                        type="text"
                        placeholder="Value"
                        value={option.value}
                        onChange={(e) => updateOption(field.id, option.id, { value: e.target.value })}
                        disabled={loading}
                      />
                      <input
                        type="text"
                        placeholder="Label"
                        value={option.label}
                        onChange={(e) => updateOption(field.id, option.id, { label: e.target.value })}
                        disabled={loading}
                      />
                      <button
                        type="button"
                        onClick={() => removeOption(field.id, option.id)}
                        disabled={loading}
                        className="button button-danger"
                      >
                        Remove
                      </button>
                    </div>
                  ))}
                  <button
                    type="button"
                    onClick={() => addOption(field.id)}
                    disabled={loading}
                    className="button button-secondary"
                  >
                    Add Option
                  </button>
                </div>
              )}
            </div>
          ))}
        </div>

        <button
          type="button"
          onClick={addField}
          disabled={loading}
          className="button button-secondary"
        >
          Add Field
        </button>

        <button
          type="submit"
          disabled={loading}
          className="button"
        >
          Save Form Schema
        </button>
      </form>
    </div>
  );
}

export default FormBuilder;

src/components/AlternativeEvaluation.js
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { authService } from '../services/auth';
import { aiService } from '../services/ai';
import { config } from '../config';

function AlternativeEvaluation() {
  const { id } = useParams();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [project, setProject] = useState(null);
  const [formData, setFormData] = useState({});
  const [alternatives, setAlternatives] = useState([]);

  useEffect(() => {
    const fetchProjectData = async () => {
      try {
        const { session } = await authService.getSession();
        const response = await fetch(`${config.NETLIFY_FUNC_URL}/projects/${id}`, {
          headers: {
            'Authorization': `Bearer ${session.access_token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error('Failed to fetch project');
        }

        const data = await response.json();
        setProject(data);

        // Fetch existing alternatives
        const altResponse = await fetch(`${config.NETLIFY_FUNC_URL}/projects/${id}/results`, {
          headers: {
            'Authorization': `Bearer ${session.access_token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!altResponse.ok) {
          throw new Error('Failed to fetch alternatives');
        }

        const altData = await altResponse.json();
        setAlternatives(altData);
      } catch (error) {
        setError(error.message);
      } finally {
        setLoading(false);
      }
    };

    fetchProjectData();
  }, [id]);

  const handleInputChange = (fieldName, value) => {
    setFormData(prev => ({
      ...prev,
      [fieldName]: value
    }));
  };

  const renderFormField = (fieldName, field) => {
    switch (field.type) {
      case 'boolean':
        return (
          <select
            value={formData[fieldName] || ''}
            onChange={(e) => handleInputChange(fieldName, e.target.value === 'true')}
            disabled={loading}
          >
            <option value="">Select...</option>
            <option value="true">Yes</option>
            <option value="false">No</option>
          </select>
        );
      case 'number':
        return (
          <input
            type="number"
            value={formData[fieldName] || ''}
            onChange={(e) => handleInputChange(fieldName, parseFloat(e.target.value))}
            disabled={loading}
          />
        );
      case 'select':
        return (
          <select
            value={formData[fieldName] || ''}
            onChange={(e) => handleInputChange(fieldName, e.target.value)}
            disabled={loading}
          >
            <option value="">Select...</option>
            {field.enum.map((value, index) => (
              <option key={value} value={value}>
                {field.enumNames?.[index] || value}
              </option>
            ))}
          </select>
        );
      case 'date':
        return (
          <input
            type="date"
            value={formData[fieldName] || ''}
            onChange={(e) => handleInputChange(fieldName, e.target.value)}
            disabled={loading}
          />
        );
      default:
        return (
          <input
            type="text"
            value={formData[fieldName] || ''}
            onChange={(e) => handleInputChange(fieldName, e.target.value)}
            disabled={loading}
          />
        );
    }
  };

  const [isEvaluating, setIsEvaluating] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    try {
      // First, get AI evaluation
      setIsEvaluating(true);
      const aiEvaluation = await aiService.evaluateAlternative(formData, {
        mustHave: project.criteria.must_have,
        want: project.criteria.want
      });

      // Submit alternative with AI evaluation
      const { session } = await authService.getSession();
      const response = await fetch(`${config.NETLIFY_FUNC_URL}/projects/${id}/evaluate`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          alternative: formData,
          evaluation: aiEvaluation
        })
      });

      if (!response.ok) {
        throw new Error('Failed to submit alternative');
      }

      const data = await response.json();
      setAlternatives([...alternatives, data]);
      setFormData({});
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
      setIsEvaluating(false);
    }
  };

  const handleNewCriteria = async () => {
    if (alternatives.length === 0) return;

    try {
      setLoading(true);
      const predictions = await Promise.all(
        alternatives.map(alt => 
          aiService.predictScores(
            alt.data,
            project.criteria,
            alt.evaluation
          )
        )
      );

      // Update alternatives with predicted scores
      const updatedAlternatives = alternatives.map((alt, index) => ({
        ...alt,
        evaluation: {
          ...alt.evaluation,
          ...predictions[index]
        }
      }));

      setAlternatives(updatedAlternatives);
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <p>Loading...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  if (!project?.form_schema || !project?.criteria) {
    return (
      <div>
        <h2>Project Setup Required</h2>
        <p>Please complete the project setup before evaluating alternatives:</p>
        <ul>
          {!project?.criteria && <li>Define evaluation criteria</li>}
          {!project?.form_schema && <li>Create input form</li>}
        </ul>
      </div>
    );
  }

  return (
    <div className="alternative-evaluation">
      <h2>Evaluate Alternative</h2>
      {error && <div className="error">{error}</div>}

      <div className="evaluation-sections">
        {project?.criteria && (
          <div className="ai-assistance">
            <p>AI will help evaluate alternatives against your criteria and provide suggested scores.</p>
            {alternatives.length > 0 && (
              <button
                onClick={handleNewCriteria}
                disabled={loading}
                className="button button-secondary"
              >
                Update Scores for New Criteria
              </button>
            )}
          </div>
        )}
        <section className="new-alternative">
          <h3>Add New Alternative</h3>
          <form onSubmit={handleSubmit}>
            {Object.entries(project.form_schema.properties).map(([fieldName, field]) => (
              <div key={fieldName} className="form-field">
                <label>
                  {field.title}
                  {project.form_schema.required?.includes(fieldName) && ' *'}
                </label>
                {renderFormField(fieldName, field)}
              </div>
            ))}
            <button 
              type="submit" 
              className="button" 
              disabled={loading || isEvaluating}
            >
              {isEvaluating ? 'AI Evaluating...' : 'Submit Alternative'}
            </button>
          </form>
        </section>

        <section className="alternatives-list">
          <h3>Evaluated Alternatives</h3>
          {alternatives.length === 0 ? (
            <p>No alternatives evaluated yet.</p>
          ) : (
            <table>
              <thead>
                <tr>
                  <th>Alternative</th>
                  <th>Status</th>
                  <th>Score</th>
                </tr>
              </thead>
              <tbody>
                {alternatives.map((alt) => (
                  <tr key={alt.id} className={alt.disqualified ? 'disqualified' : ''}>
                    <td>
                      {Object.entries(alt.data).map(([key, value]) => (
                        <div key={key}>
                          <strong>{project.form_schema.properties[key].title}:</strong>{' '}
                          {value.toString()}
                        </div>
                      ))}
                    </td>
                    <td>{alt.disqualified ? 'Disqualified' : 'Qualified'}</td>
                    <td>{alt.score.toFixed(2)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </section>
      </div>
    </div>
  );
}

export default AlternativeEvaluation;

src/components/__tests__/ThemeSelector.test.js
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import ThemeSelector from '../ThemeSelector';
import { ThemeProvider, themes } from '../../themes/ThemeContext';

describe('ThemeSelector', () => {
  const renderWithTheme = (component) => {
    return render(
      <ThemeProvider>
        {component}
      </ThemeProvider>
    );
  };

  it('renders all theme buttons', () => {
    renderWithTheme(<ThemeSelector />);
    
    expect(screen.getByText('MUI Theme')).toBeInTheDocument();
    expect(screen.getByText('Wood Theme')).toBeInTheDocument();
    expect(screen.getByText('Metallic Theme')).toBeInTheDocument();
  });

  it('renders dark mode toggle', () => {
    renderWithTheme(<ThemeSelector />);
    
    const darkModeToggle = screen.getByRole('checkbox');
    expect(darkModeToggle).toBeInTheDocument();
    expect(darkModeToggle).not.toBeChecked();
  });

  it('applies active class to current theme button', () => {
    renderWithTheme(<ThemeSelector />);
    
    const muiButton = screen.getByRole('button', { name: 'MUI Theme' });
    const woodButton = screen.getByRole('button', { name: 'Wood Theme' });
    
    expect(muiButton).toHaveClass('active');
    expect(woodButton).not.toHaveClass('active');
  });

  it('changes theme when clicking theme buttons', () => {
    renderWithTheme(<ThemeSelector />);
    
    const woodButton = screen.getByRole('button', { name: 'Wood Theme' });
    fireEvent.click(woodButton);
    
    expect(woodButton).toHaveClass('active');
    expect(screen.getByRole('button', { name: 'MUI Theme' })).not.toHaveClass('active');
  });

  it('toggles dark mode', () => {
    renderWithTheme(<ThemeSelector />);
    
    const darkModeToggle = screen.getByRole('checkbox');
    fireEvent.click(darkModeToggle);
    
    expect(darkModeToggle).toBeChecked();
  });

  it('applies correct styles based on theme', () => {
    renderWithTheme(<ThemeSelector />);
    
    // Check MUI theme button styles
    const muiButton = screen.getByRole('button', { name: 'MUI Theme' });
    expect(muiButton).toHaveStyle({
      backgroundColor: themes.mui.colors.primary
    });

    // Check Wood theme button styles
    const woodButton = screen.getByRole('button', { name: 'Wood Theme' });
    expect(woodButton).toHaveStyle({
      backgroundColor: themes.wood.colors.primary
    });

    // Check Metallic theme button styles
    const metallicButton = screen.getByRole('button', { name: 'Metallic Theme' });
    expect(metallicButton).toHaveStyle({
      backgroundColor: themes.metallic.colors.primary
    });
  });

  it('maintains theme selection after dark mode toggle', () => {
    renderWithTheme(<ThemeSelector />);
    
    // Select Wood theme
    const woodButton = screen.getByRole('button', { name: 'Wood Theme' });
    fireEvent.click(woodButton);
    expect(woodButton).toHaveClass('active');

    // Toggle dark mode
    const darkModeToggle = screen.getByRole('checkbox');
    fireEvent.click(darkModeToggle);

    // Wood theme should still be selected
    expect(woodButton).toHaveClass('active');
  });

  it('applies hover styles to theme buttons', () => {
    renderWithTheme(<ThemeSelector />);
    
    const woodButton = screen.getByRole('button', { name: 'Wood Theme' });
    
    // Simulate hover
    fireEvent.mouseEnter(woodButton);
    expect(woodButton).toHaveStyle({
      transform: 'translateY(-2px)'
    });

    // Simulate hover end
    fireEvent.mouseLeave(woodButton);
    expect(woodButton).not.toHaveStyle({
      transform: 'translateY(-2px)'
    });
  });

  it('renders in a fixed position', () => {
    renderWithTheme(<ThemeSelector />);
    
    const themeSelector = screen.getByTestId('theme-selector');
    
    expect(themeSelector).toHaveStyle({
      position: 'fixed',
      bottom: '20px',
      right: '20px',
      zIndex: '1000'
    });
  });
});

src/components/Dashboard.js
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { authService } from '../services/auth';
import { aiService } from '../services/ai';
import { config } from '../config';

function Dashboard() {
  const [projects, setProjects] = useState([]);
  const [loading, setLoading] = useState(false);
  const [newProjectGoal, setNewProjectGoal] = useState('');
  const [newProjectNotes, setNewProjectNotes] = useState('');
  const [showNewProjectForm, setShowNewProjectForm] = useState(false);
  const [aiSuggestions, setAiSuggestions] = useState(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [acceptedCriteria, setAcceptedCriteria] = useState(new Set());

  useEffect(() => {
    const fetchProjects = async () => {
      setLoading(true);
      try {
        const { session } = await authService.getSession();
        const response = await fetch(`${config.NETLIFY_FUNC_URL}/projects`, {
          headers: {
            'Authorization': `Bearer ${session.access_token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error('Failed to fetch projects');
        }

        const data = await response.json();
        setProjects(data || []);
      } catch (error) {
        alert(error.message);
      } finally {
        setLoading(false);
      }
    };

    fetchProjects();
  }, []);

  const generateSuggestions = async () => {
    if (!newProjectGoal.trim()) {
      alert('Please enter a project goal');
      return;
    }

    setIsGenerating(true);
    try {
      const suggestions = await aiService.generateCriteria(newProjectGoal);
      // Add IDs to criteria for tracking acceptance
      suggestions.mustHave = suggestions.mustHave.map(c => ({ ...c, id: Date.now() + Math.random() }));
      suggestions.want = suggestions.want.map(c => ({ ...c, id: Date.now() + Math.random() }));
      setAiSuggestions(suggestions);
    } catch (error) {
      alert(error.message);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleAcceptCriterion = (type, id) => {
    setAcceptedCriteria(prev => new Set([...prev, `${type}-${id}`]));
  };

  const handleRejectCriterion = (type, id) => {
    const criteriaSet = new Set(acceptedCriteria);
    criteriaSet.delete(`${type}-${id}`);
    setAcceptedCriteria(criteriaSet);
  };

  const handleAcceptAll = () => {
    const allIds = [
      ...aiSuggestions.mustHave.map(c => `must-${c.id}`),
      ...aiSuggestions.want.map(c => `want-${c.id}`)
    ];
    setAcceptedCriteria(new Set(allIds));
  };

  const handleRejectAll = () => {
    setAcceptedCriteria(new Set());
  };

  const handleCreateProject = async () => {
    if (!newProjectGoal.trim()) {
      alert('Please enter a project goal');
      return;
    }

    if (aiSuggestions) {
      // Get accepted criteria
      const acceptedMustHave = aiSuggestions.mustHave.filter(c => 
        acceptedCriteria.has(`must-${c.id}`)
      );
      const acceptedWant = aiSuggestions.want.filter(c => 
        acceptedCriteria.has(`want-${c.id}`)
      );

      if (acceptedMustHave.length === 0 && acceptedWant.length === 0) {
        alert('Please accept at least one criterion before creating the project');
        return;
      }
    }

    setLoading(true);
    try {
      const { session } = await authService.getSession();
      const response = await fetch(`${config.NETLIFY_FUNC_URL}/projects`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          name: newProjectGoal,
          description: newProjectNotes,
          criteria: aiSuggestions ? {
            mustHave: aiSuggestions.mustHave.filter(c => acceptedCriteria.has(`must-${c.id}`)),
            want: aiSuggestions.want.filter(c => acceptedCriteria.has(`want-${c.id}`))
          } : null
        })
      });

      if (!response.ok) {
        throw new Error('Failed to create project');
      }

      const data = await response.json();
      setProjects([...projects, data]);
      setNewProjectGoal('');
      setNewProjectNotes('');
      setShowNewProjectForm(false);
      setAiSuggestions(null);
      setAcceptedCriteria(new Set());
    } catch (error) {
      alert(error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <h2>Dashboard</h2>
      <button onClick={() => setShowNewProjectForm(!showNewProjectForm)}>
        {showNewProjectForm ? 'Cancel' : 'Create New Project'}
      </button>

      {showNewProjectForm && (
        <div className="new-project-form">
          <div className="form-section">
            <input
              type="text"
              placeholder="What decision do you need to make? (e.g., 'Which house to buy')"
              value={newProjectGoal}
              onChange={(e) => setNewProjectGoal(e.target.value)}
              disabled={loading || isGenerating}
            />
            <textarea
              placeholder="Additional notes or context"
              value={newProjectNotes}
              onChange={(e) => setNewProjectNotes(e.target.value)}
              disabled={loading || isGenerating}
            />
            {!aiSuggestions && (
              <button 
                onClick={generateSuggestions} 
                disabled={loading || isGenerating || !newProjectGoal.trim()}
                className="button button-secondary"
              >
                {isGenerating ? 'Generating Suggestions...' : 'Get AI Suggestions'}
              </button>
            )}
          </div>

          {aiSuggestions && (
            <div className="ai-suggestions">
              <div className="warning-banner">
                Please review and accept/reject the AI-suggested criteria before proceeding
              </div>
              
              <div className="bulk-actions">
                <button onClick={handleAcceptAll} className="button button-secondary">
                  Accept All
                </button>
                <button onClick={handleRejectAll} className="button button-secondary">
                  Reject All
                </button>
              </div>

              <div className="criteria-sections">
                <div className="criteria-section">
                  <h3>Must-Have Criteria</h3>
                  {aiSuggestions.mustHave.map(criteria => (
                    <div 
                      key={criteria.id} 
                      className={`criteria-item ${acceptedCriteria.has(`must-${criteria.id}`) ? '' : 'pending'}`}
                    >
                      <div className="criteria-content">
                        <strong>{criteria.name}</strong>
                        <p>{criteria.description}</p>
                      </div>
                      <div className="criteria-actions">
                        {acceptedCriteria.has(`must-${criteria.id}`) ? (
                          <button 
                            onClick={() => handleRejectCriterion('must', criteria.id)}
                            className="button button-danger"
                          >
                            Reject
                          </button>
                        ) : (
                          <button 
                            onClick={() => handleAcceptCriterion('must', criteria.id)}
                            className="button"
                          >
                            Accept
                          </button>
                        )}
                      </div>
                    </div>
                  ))}
                </div>

                <div className="criteria-section">
                  <h3>Want Criteria</h3>
                  {aiSuggestions.want.map(criteria => (
                    <div 
                      key={criteria.id} 
                      className={`criteria-item ${acceptedCriteria.has(`want-${criteria.id}`) ? '' : 'pending'}`}
                    >
                      <div className="criteria-content">
                        <strong>{criteria.name}</strong>
                        <p>{criteria.description}</p>
                        <span className="weight">Weight: {criteria.weight}</span>
                      </div>
                      <div className="criteria-actions">
                        {acceptedCriteria.has(`want-${criteria.id}`) ? (
                          <button 
                            onClick={() => handleRejectCriterion('want', criteria.id)}
                            className="button button-danger"
                          >
                            Reject
                          </button>
                        ) : (
                          <button 
                            onClick={() => handleAcceptCriterion('want', criteria.id)}
                            className="button"
                          >
                            Accept
                          </button>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              </div>

              <div className="warning-banner">
                Please review and accept/reject the AI-suggested criteria before proceeding
              </div>
            </div>
          )}

          <button 
            onClick={handleCreateProject} 
            disabled={loading || isGenerating}
            className="button"
          >
            Create Project
          </button>
        </div>
      )}

      {loading ? (
        <p>Loading projects...</p>
      ) : (
        <ul className="projects-list">
          {projects.map((project) => (
            <li key={project.id}>
              <Link to={`/projects/${project.id}`}>
                <h3>{project.name}</h3>
                <p>{project.description}</p>
                <div className="project-status">
                  {project.criteria && (
                    <span className="status-badge ai-suggested">
                      AI-Suggested Criteria
                    </span>
                  )}
                  {project.form_schema && (
                    <span className="status-badge">
                      Form Schema Defined
                    </span>
                  )}
                </div>
              </Link>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

export default Dashboard;

src/App.test.js
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

src/setupTests.js
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

src/themes/patterns.js
// Base64 encoded wood texture pattern
export const woodPattern = `data:image/svg+xml;base64,${btoa(`
<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <pattern id="woodgrain" patternUnits="userSpaceOnUse" width="100" height="100">
      <rect width="100" height="100" fill="#8B4513"/>
      <filter id='noise' x='0%' y='0%' width='100%' height='100%'>
        <feTurbulence type="fractalNoise" baseFrequency="0.5" numOctaves="3" result="noise"/>
        <feColorMatrix type="saturate" values="0.1" in="noise" result="noise2"/>
        <feBlend in="SourceGraphic" in2="noise2" mode="multiply"/>
      </filter>
      <rect width="100" height="100" filter="url(#noise)" opacity="0.1"/>
      <path d="M0 20 Q25 18, 50 20 T100 20" stroke="#A0522D" stroke-width="0.5" fill="none" opacity="0.3"/>
      <path d="M0 40 Q25 38, 50 40 T100 40" stroke="#A0522D" stroke-width="0.5" fill="none" opacity="0.3"/>
      <path d="M0 60 Q25 58, 50 60 T100 60" stroke="#A0522D" stroke-width="0.5" fill="none" opacity="0.3"/>
      <path d="M0 80 Q25 78, 50 80 T100 80" stroke="#A0522D" stroke-width="0.5" fill="none" opacity="0.3"/>
    </pattern>
  </defs>
  <rect width="100" height="100" fill="url(#woodgrain)"/>
</svg>
`)}`;

// Base64 encoded metallic pattern
export const metallicPattern = `data:image/svg+xml;base64,${btoa(`
<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="metallic" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#B0BEC5;stop-opacity:1" />
      <stop offset="50%" style="stop-color:#CFD8DC;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#B0BEC5;stop-opacity:1" />
    </linearGradient>
    <filter id="noise">
      <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" result="noise"/>
      <feColorMatrix type="saturate" values="0" in="noise" result="noise2"/>
      <feBlend in="SourceGraphic" in2="noise2" mode="overlay"/>
    </filter>
  </defs>
  <rect width="100" height="100" fill="url(#metallic)" filter="url(#noise)"/>
</svg>
`)}`;

src/themes/__tests__/ThemeContext.test.js
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { ThemeProvider, useTheme } from '../ThemeContext';
import { themes } from '../ThemeContext';

// Test component that uses the theme context
function TestComponent() {
  const { theme, changeTheme, isDarkMode, toggleDarkMode } = useTheme();
  return (
    <div>
      <div data-testid="theme-name">{theme.name}</div>
      <div data-testid="is-dark-mode">{isDarkMode.toString()}</div>
      <button onClick={() => changeTheme('wood')}>Change to Wood</button>
      <button onClick={toggleDarkMode}>Toggle Dark Mode</button>
    </div>
  );
}

describe('ThemeContext', () => {
  it('provides default theme (mui) to children', () => {
    render(
      <ThemeProvider>
        <TestComponent />
      </ThemeProvider>
    );
    
    expect(screen.getByTestId('theme-name')).toHaveTextContent('mui');
  });

  it('allows changing themes', () => {
    render(
      <ThemeProvider>
        <TestComponent />
      </ThemeProvider>
    );
    
    fireEvent.click(screen.getByText('Change to Wood'));
    expect(screen.getByTestId('theme-name')).toHaveTextContent('wood');
  });

  it('allows toggling dark mode', () => {
    render(
      <ThemeProvider>
        <TestComponent />
      </ThemeProvider>
    );
    
    expect(screen.getByTestId('is-dark-mode')).toHaveTextContent('false');
    fireEvent.click(screen.getByText('Toggle Dark Mode'));
    expect(screen.getByTestId('is-dark-mode')).toHaveTextContent('true');
  });

  it('applies dark mode color modifications', () => {
    render(
      <ThemeProvider>
        <TestComponent />
      </ThemeProvider>
    );
    
    // Get initial background color
    const { theme: initialTheme } = useTheme();
    const initialBackground = initialTheme.colors.background;

    // Toggle dark mode
    fireEvent.click(screen.getByText('Toggle Dark Mode'));

    // Get updated background color
    const { theme: updatedTheme } = useTheme();
    const darkBackground = updatedTheme.colors.background;

    expect(darkBackground).toBe('#121212');
    expect(darkBackground).not.toBe(initialBackground);
  });

  it('throws error when useTheme is used outside ThemeProvider', () => {
    // Suppress console.error for this test
    const consoleSpy = jest.spyOn(console, 'error');
    consoleSpy.mockImplementation(() => {});

    expect(() => {
      render(<TestComponent />);
    }).toThrow('useTheme must be used within a ThemeProvider');

    consoleSpy.mockRestore();
  });

  it('verifies all themes have required properties', () => {
    const requiredProperties = [
      'name',
      'colors',
      'fonts',
      'shadows',
      'borderRadius'
    ];

    const requiredColors = [
      'primary',
      'secondary',
      'background',
      'surface',
      'text',
      'textSecondary',
      'border'
    ];

    Object.values(themes).forEach(theme => {
      // Check required top-level properties
      requiredProperties.forEach(prop => {
        expect(theme).toHaveProperty(prop);
      });

      // Check required color properties
      requiredColors.forEach(color => {
        expect(theme.colors).toHaveProperty(color);
      });

      // Check font properties
      expect(theme.fonts).toHaveProperty('primary');
      expect(theme.fonts).toHaveProperty('secondary');

      // Check shadow properties
      expect(theme.shadows).toHaveProperty('small');
      expect(theme.shadows).toHaveProperty('medium');
      expect(theme.shadows).toHaveProperty('large');
    });
  });
});

src/themes/ThemeContext.js
import React, { createContext, useContext, useState } from 'react';
import { woodPattern, metallicPattern } from './patterns';
import '../styles/fonts.css';

const ThemeContext = createContext();

export const themes = {
  mui: {
    name: 'mui',
    colors: {
      primary: '#1976d2',
      secondary: '#dc004e',
      background: '#ffffff',
      surface: '#f5f5f5',
      text: '#000000',
      textSecondary: '#666666',
      border: '#e0e0e0'
    },
    fonts: {
      primary: 'Roboto, sans-serif',
      secondary: 'Roboto, sans-serif'
    },
    shadows: {
      small: '0 2px 4px rgba(0,0,0,0.1)',
      medium: '0 4px 6px rgba(0,0,0,0.1)',
      large: '0 8px 16px rgba(0,0,0,0.1)'
    },
    borderRadius: '4px'
  },
  wood: {
    name: 'wood',
    colors: {
      primary: '#8B4513',
      secondary: '#A0522D',
      background: '#FFF8DC',
      surface: '#FAEBD7',
      text: '#3E2723',
      textSecondary: '#5D4037',
      border: '#DEB887'
    },
    fonts: {
      primary: 'Merriweather, serif',
      secondary: 'Lora, serif'
    },
    shadows: {
      small: '0 2px 4px rgba(139,69,19,0.1)',
      medium: '0 4px 6px rgba(139,69,19,0.1)',
      large: '0 8px 16px rgba(139,69,19,0.1)'
    },
    borderRadius: '8px',
    backgroundImage: woodPattern,
    backgroundOverlay: 'rgba(255, 248, 220, 0.9)',
    backgroundSize: '100px 100px'
  },
  metallic: {
    name: 'metallic',
    colors: {
      primary: '#607D8B',
      secondary: '#546E7A',
      background: '#ECEFF1',
      surface: '#CFD8DC',
      text: '#263238',
      textSecondary: '#455A64',
      border: '#B0BEC5'
    },
    fonts: {
      primary: 'Rajdhani, sans-serif',
      secondary: 'Orbitron, sans-serif'
    },
    shadows: {
      small: '0 2px 4px rgba(96,125,139,0.2)',
      medium: '0 4px 6px rgba(96,125,139,0.2)',
      large: '0 8px 16px rgba(96,125,139,0.2)'
    },
    borderRadius: '2px',
    backgroundImage: metallicPattern,
    backgroundSize: '100px 100px'
  }
};

export function ThemeProvider({ children }) {
  const [currentTheme, setCurrentTheme] = useState(themes.mui);
  const [isDarkMode, setIsDarkMode] = useState(false);

  const toggleDarkMode = () => {
    setIsDarkMode(!isDarkMode);
  };

  const changeTheme = (themeName) => {
    setCurrentTheme(themes[themeName]);
  };

  // Apply dark mode modifications to the current theme
  const theme = {
    ...currentTheme,
    colors: {
      ...currentTheme.colors,
      background: isDarkMode ? '#121212' : currentTheme.colors.background,
      surface: isDarkMode ? '#1E1E1E' : currentTheme.colors.surface,
      text: isDarkMode ? '#FFFFFF' : currentTheme.colors.text,
      textSecondary: isDarkMode ? '#AAAAAA' : currentTheme.colors.textSecondary,
      border: isDarkMode ? '#333333' : currentTheme.colors.border
    }
  };

  return (
    <ThemeContext.Provider value={{ theme, changeTheme, isDarkMode, toggleDarkMode }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}

src/App.js
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Link, useNavigate } from 'react-router-dom';
import './App.css';
import Dashboard from './components/Dashboard';
import ProjectView from './components/ProjectView';
import CriteriaDefinition from './components/CriteriaDefinition';
import FormBuilder from './components/FormBuilder';
import AlternativeEvaluation from './components/AlternativeEvaluation';
import ThemeSelector from './components/ThemeSelector';
import { ThemeProvider, useTheme } from './themes/ThemeContext';
import { authService } from './services/auth';
import Auth from './components/Auth'; // Import the Auth component

// Wrapper component to apply theme styles
function ThemedApp({ children }) {
  const { theme } = useTheme();

  useEffect(() => {
    // Update CSS variables based on theme
    document.documentElement.style.setProperty('--primary-color', theme.colors.primary);
    document.documentElement.style.setProperty('--secondary-color', theme.colors.secondary);
    document.documentElement.style.setProperty('--background-color', theme.colors.background);
    document.documentElement.style.setProperty('--surface-color', theme.colors.surface);
    document.documentElement.style.setProperty('--text-color', theme.colors.text);
    document.documentElement.style.setProperty('--text-secondary-color', theme.colors.textSecondary);
    document.documentElement.style.setProperty('--border-color', theme.colors.border);
    document.documentElement.style.setProperty('--font-primary', theme.fonts.primary);
    document.documentElement.style.setProperty('--font-secondary', theme.fonts.secondary);
    document.documentElement.style.setProperty('--border-radius', theme.borderRadius);

    // Apply theme-specific background
    if (theme.backgroundImage) {
      document.body.style.backgroundImage = theme.backgroundImage;
      document.body.style.backgroundSize = theme.backgroundSize || 'cover';
    } else {
      document.body.style.backgroundImage = 'none';
    }

    document.body.style.backgroundColor = theme.colors.background;
    document.body.style.color = theme.colors.text;
    document.body.style.fontFamily = theme.fonts.primary;
  }, [theme]);

  return children;
}

function App() {
  const [session, setSession] = useState(null);
  const navigate = useNavigate();

  useEffect(() => {
    const checkSession = async () => {
      try {
        const { session } = await authService.getSession();
        setSession(session);
      } catch (error) {
        console.error('Session check failed:', error);
        setSession(null);
      }
    };

    checkSession(); // Initial session check
    // Poll for session changes every minute
    const interval = setInterval(checkSession, 60000);

    // Navigate to '/' when session becomes null (sign out)
    if (session === null) {
      navigate('/');
    }

    return () => clearInterval(interval);
  }, [session, navigate]);

  const handleSignIn = async () => {
    try {
      const { session: newSession } = await authService.getSession();
      setSession(newSession);
    } catch (error) {
      console.error('Sign in failed:', error);
    }
  }

  const handleSignOut = async () => {
    try {
      await authService.signOut();
      setSession(null);
    } catch (error) {
      console.error('Sign out failed:', error);
    }
  };

  return (
    <ThemeProvider>
      <Router future={{ v7_startTransition: true, v7_relativeSplatPath: true }}>
        <ThemedApp>
          <div className="App">
            <nav>
              <ul>
                <li>
                  <Link to="/">Dashboard</Link>
                </li>
                <li>
                  <Link to="/criteria">Criteria Definition</Link>
                </li>
                <li>
                  <Link to="/evaluation">Alternative Evaluation</Link>
                </li>
                {session && (
                  <li>
                    <button onClick={handleSignOut}>Sign Out</button>
                  </li>
                )}
              </ul>
            </nav>

            <Routes>
              <Route path="/" element={session ? <Dashboard /> : <Auth onSignIn={handleSignIn} />} />
              <Route path="/projects/:id" element={<ProjectView />} />
              <Route path="/projects/:id/criteria" element={<CriteriaDefinition />} />
              <Route path="/projects/:id/form" element={<FormBuilder />} />
              <Route path="/projects/:id/evaluate" element={<AlternativeEvaluation />} />
            </Routes>
            <ThemeSelector />
          </div>
        </ThemedApp>
      </Router>
    </ThemeProvider>
  );
}

export default App;

src/services/ai.js
import { config } from '../config';
import { authService } from './auth';

export const aiService = {
  async generateCriteria(concept) {
    try {
      if (config.DEBUG) {
        console.log("[aiService] generateCriteria called with:", concept);
      }
      const { session } = await authService.getSession();
      const response = await fetch(`${config.NETLIFY_FUNC_URL}/ai/generate-criteria`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ concept })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to generate criteria');
      }

      const result = await response.json();
      if (config.DEBUG) {
        console.log("[aiService] generateCriteria result:", result);
      }
      return result;
    } catch (error) {
      console.error('Generate Criteria Error:', error);
      throw error;
    }
  },

  async evaluateAlternative(alternative, criteria) {
    try {
      if (config.DEBUG) {
        console.log("[aiService] evaluateAlternative called with:", alternative, criteria);
      }
      const { session } = await authService.getSession();
      const response = await fetch(`${config.NETLIFY_FUNC_URL}/ai/evaluate-alternative`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ alternative, criteria })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to evaluate alternative');
      }

      const result = await response.json();
      if (config.DEBUG) {
        console.log("[aiService] evaluateAlternative result:", result);
      }
      return result;
    } catch (error) {
      console.error('Evaluate Alternative Error:', error);
      throw error;
    }
  },

  async predictScores(alternative, newCriteria, existingCriteria) {
    try {
      if (config.DEBUG) {
        console.log("[aiService] predictScores called with:", alternative, newCriteria, existingCriteria);
      }
      const { session } = await authService.getSession();
      const response = await fetch(`${config.NETLIFY_FUNC_URL}/ai/predict-scores`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ alternative, newCriteria, existingCriteria })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to predict scores');
      }
      
      const result = await response.json();
      if (config.DEBUG) {
        console.log("[aiService] predictScores result:", result);
      }
      return result;
    } catch (error) {
      console.error('Predict Scores Error:', error);
      throw error;
    }
  }
};

src/services/auth.js
import { config } from "../config";

// Helper function to get the session token from cookies
function getTokenFromCookie() {
    const cookieString = document.cookie || '';
    const cookies = cookieString.split(';').reduce((acc, cookie) => {
        const [key, value] = cookie.trim().split('=');
        acc[key] = value;
        return acc;
    }, {});

    const projectRef = localStorage.getItem('supabaseProjectRef');
    if (!projectRef) {
      return null;
    }
    const sessionCookieName = `sb-${projectRef}-auth-token`;
    return cookies[sessionCookieName];
}

export const authService = {
  async signUp(email, password) {
    if (config.DEBUG) {
      console.log("[authService] signUp called with:", email, password);
    }
    const response = await fetch(`${config.NETLIFY_FUNC_URL}/signup`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "Failed to sign up");
    }

    const result = await response.json();
    if (config.DEBUG) {
      console.log("[authService] signUp result:", result);
    }
    return result;
  },

  async signIn(email, password) {
    if (config.DEBUG) {
      console.log("[authService] signIn called with:", email, password);
    }
    const response = await fetch(`${config.NETLIFY_FUNC_URL}/signin`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "Failed to sign in");
    }

    const result = await response.json();
    if (config.DEBUG) {
      console.log("[authService] signIn result:", result);
    }
    // Store the projectRef in local storage
    localStorage.setItem('supabaseProjectRef', result.projectRef);
    return result;
  },

  async signOut() {
    if (config.DEBUG) {
      console.log("[authService] signOut called");
    }
     // Clear projectRef on sign out
    localStorage.removeItem('supabaseProjectRef');
    const response = await fetch(`${config.NETLIFY_FUNC_URL}/signout`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "Failed to sign out");
    }

    const result = await response.json();
    if (config.DEBUG) {
      console.log("[authService] signOut result:", result);
    }
    return result;
  },

  async getSession() {
    if (config.DEBUG) {
      console.log("[authService] getSession called");
    }
    const token = getTokenFromCookie();
    if (!token) {
      if (config.DEBUG) {
        console.log("[authService] No token found");
      }
      throw new Error("No session token found"); // Consistent with original error
    }
    const response = await fetch(`${config.NETLIFY_FUNC_URL}/session`, {
      headers: {
        "Content-Type": "application/json",
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "Failed to get session");
    }

    const result = await response.json();
    if (config.DEBUG) {
      console.log("[authService] getSession result:", result);
    }
    return result;
  },
};

public/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

public/manifest.json
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

public/robots.txt
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

=======
